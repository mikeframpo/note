#!/usr/bin/python3

import argparse
from argparse import RawTextHelpFormatter
from pathlib import Path, PurePath
import sys
import os.path
import os
import itertools
from subprocess import call
from datetime import datetime

NOTES_PATH = Path.joinpath(Path.home(), 'Drive/Notes')
DISPLAY_LIMIT = 10

def do_new(args):
    cats = list(get_categories())
    for i, v in enumerate(cats):
        print('({}) {}'.format(i, str(v.relative_to(NOTES_PATH))))
    cat_num = int(input('Creating new notes file, select category folder\n'))
    
    dest_dir = cats[cat_num]
    desc = input('Enter note file name or space-separated tags\n')
    
    note_name = '{}-{}.md'.format(
        datetime.today().strftime('%y%m%d'),
        desc.replace(' ', '-'))
    note_dest = PurePath.joinpath(dest_dir, note_name)
    input('Creating new note with name {}, <Enter> to continue...'.format(
        note_dest))
    call_editor(note_dest)

def do_list(args):
    list_notes()

def do_edit(args):
    list_notes()
    note_num = int(input('Select notes file for editing\n'))
    
    notes_files = get_notes(DISPLAY_LIMIT)
    note = next(itertools.islice(notes_files, note_num, None))
    call_editor(note)

def do_list_categories(args):
    categories = get_categories()
    print('Listing {} categories in alphabetical order'.format(DISPLAY_LIMIT))
    for i, v in enumerate(categories):
        print('({}) {}'.format(i, str(v.relative_to(NOTES_PATH))))

def do_new_category(args):
    print('Enter path to new category in format: parent/new-category')
    cat_dir = input()
    new_category(cat_dir)

def list_notes():
    notes_files = get_notes(DISPLAY_LIMIT)
    print('Listing {} notes. Recently modified first'.format(DISPLAY_LIMIT))
    for i, v in enumerate(notes_files):
        print('({}) {}'.format(i, str(v.relative_to(NOTES_PATH))))

def get_notes(limit):
    notes_files = []
    walk_notes_dir(NOTES_PATH, notes_files)

    notes_files = reversed(sorted(notes_files, key=os.path.getmtime))
    return itertools.islice(notes_files, limit)

def get_categories():
    cats = []
    walk_notes_dir(NOTES_PATH, cats, False)
    cat_dirs = sorted(cats)
    return cat_dirs

def new_category(cat_dir):
    cat_path = PurePath.joinpath(NOTES_PATH, cat_dir)
    if cat_path.exists():
        print('Category {} already exists'.format(cat_dir))
        return
    try:
        cat_path.mkdir()
        print('Created category: {}'.format(cat_dir))
    except FileNotFoundError:
        print('Failed to create {}, make sure parent category exists'.format(cat_path))

def call_editor(note_file):
    editor = os.environ.get('NOTE_EDITOR')
    if editor is None:
        print('Warning: environment variable NOTE_EDITOR not set, defaulting to vim')
        editor = os.environ.get('EDITOR', 'vim')
    call([editor, note_file])

def walk_notes_dir(path_elem, dest, files=True):
    if path_elem.is_dir():
        for child in path_elem.iterdir():
            if child.is_file() and child.suffix == '.md' and files:
                dest.append(child)
            elif child.is_dir():
                if not files:
                    dest.append(child)
                walk_notes_dir(child, dest, files)

COMMANDS = {
    'new': (do_new, 'Create a new note'),
    'list': (do_list, 'List existing notes'),
    'edit': (do_edit, 'Edit an existing note'),
    'lcat': (do_list_categories, 'List existing categories'),
    'ncat': (do_new_category, 'Create a new category'),
}

COMMANDS_HELP = 'one of: \n{}'.format(
                    ',\n'.join(
                        map(lambda key: '\t{}: \t{}'.format(key, COMMANDS[key][1]),
                            COMMANDS)
                    )
                )

parser = argparse.ArgumentParser(formatter_class=RawTextHelpFormatter)
parser.add_argument('command', help=COMMANDS_HELP)
args = parser.parse_args()

if not NOTES_PATH.exists():
    print('Warning: expected notes path {} does not exist'.format(NOTES_PATH))

if args.command not in COMMANDS:
    print('command \"{}\" is invalid'.format(args.command), file=sys.stderr)
    sys.exit(1)

# run the command
COMMANDS[args.command][0](args)

